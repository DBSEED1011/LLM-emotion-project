---
title: "study2_GLMM"
author: "dyq"
date: "2025-09-05"
output: html_document
---

## R Markdown

```{r}
# ============ 安装并加载依赖包 ============
packs <- c("readxl", "dplyr", "lme4", "broom.mixed", "emmeans", "readr")
to_install <- setdiff(packs, rownames(installed.packages()))
if (length(to_install) > 0) install.packages(to_install, dependencies = TRUE)
invisible(lapply(packs, library, character.only = TRUE))
```

```{r}
# ============ 读取数据 ============
file_path <- "~/Desktop/study2_GLMM.xlsx"
df <- readxl::read_excel(file_path)

cat("列名：\n"); print(names(df))
cat("\nchoice/Agent_type/Emotion_selfreport 的原始取值频数：\n")
print(table(df$choice, useNA = "ifany"))
print(table(df$Agent_type, useNA = "ifany"))
print(table(df$Emotion_selfreport, useNA = "ifany"))
```

```{r cars}
# ============ 因子化（显式levels，避免标签长度错误） ============
# 你的预期：choice = 0/1；Agent_type = 1/2/3；Emotion_selfreport = 0/1
# 如有超出这些level的取值，会被给出警告并标记为 NA
valid_choice_levels <- c(0, 1)
valid_agent_levels  <- c(1, 2, 3,4,5)
valid_emotion_levels <- c(0, 1)

# 标记异常
bad_choice <- setdiff(na.omit(unique(df$choice)), valid_choice_levels)
bad_agent  <- setdiff(na.omit(unique(df$Agent_type)), valid_agent_levels)
bad_emot   <- setdiff(na.omit(unique(df$Emotion_selfreport)), valid_emotion_levels)

if (length(bad_choice)>0) warning("choice 中存在非常规取值：", paste(bad_choice, collapse=", "))
if (length(bad_agent)>0)  warning("Agent_type 中存在非常规取值：", paste(bad_agent, collapse=", "))
if (length(bad_emot)>0)   warning("Emotion_selfreport 中存在非常规取值：", paste(bad_emot, collapse=", "))

expdata <- df %>%
  mutate(
    choice = factor(choice,
                    levels = valid_choice_levels,
                    labels = c("accept","punish")),
    Agent_type = factor(Agent_type,
                        levels = valid_agent_levels,
                        labels = c("DeepSeek-R1","o3-mini","Humans","DeepSeek-v3","GPT-3.5"
                            )),
    Emotion_selfreport = factor(Emotion_selfreport,
                                levels = valid_emotion_levels,
                                labels = c("No Emotion Self-Report","Emotion Self-Report")),
    ID = as.factor(ID)
  )

cat("\n因子化后频数（确认标签）：\n")
print(table(expdata$choice, useNA = "ifany"))
print(table(expdata$Agent_type, useNA = "ifany"))
print(table(expdata$Emotion_selfreport, useNA = "ifany"))


```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}

# ============ 数值控制变量中心化 ============
# 如果有缺失，会在后面 complete.cases 过滤
expdata <- expdata %>%
  mutate(
    amount_of_cost_c = scale(amount_of_cost, scale = FALSE)[,1],
    amount_of_allocation_c = scale(amount_of_allocation, scale = FALSE)[,1]
  )

# ============ 删去关键变量缺失的行（以免 glmer 报错） ============
vars_needed <- c("choice","Agent_type","Emotion_selfreport","ID",
                 "amount_of_cost_c","amount_of_allocation_c")
expdata_complete <- expdata[complete.cases(expdata[, vars_needed]), ]

cat("\n完整案例数量：", nrow(expdata_complete), " / 原始行数：", nrow(expdata), "\n")

```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
```{r}

# 确保 Agent_type 是因子
expdata_complete$Agent_type <- factor(expdata_complete$Agent_type)

# 把 "human" 设为基线水平
expdata_complete$Agent_type <- relevel(expdata_complete$Agent_type, ref = "Humans")

# ============ 模型1：无交互 ============
m0 <- glmer(
  choice ~ Agent_type + Emotion_selfreport +
    amount_of_cost_c + amount_of_allocation_c +
    (1 | ID),
  data = expdata_complete,
  family = binomial(link = "logit"),
  control = glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 1e5))
)

cat("\n===== 模型1（无交互）结果 =====\n")
print(summary(m0))

# OR 与 95% CI
or_m0 <- broom.mixed::tidy(m0, effects = "fixed", conf.int = TRUE, conf.method = "Wald") %>%
  mutate(
    OR = exp(estimate),
    OR_low = exp(conf.low),
    OR_high = exp(conf.high)
  ) %>%
  select(term, estimate, std.error, statistic, p.value, OR, OR_low, OR_high)

cat("\n===== 模型1 OR (95%CI) =====\n")
print(or_m0, digits = 4)
```
```{r}
# ============ 模型2：含交互（Agent_type * Emotion_selfreport） ============
# 确保 Agent_type 是因子
expdata_complete$Agent_type <- factor(expdata_complete$Agent_type)

# 把 "human" 设为基线水平
expdata_complete$Agent_type <- relevel(expdata_complete$Agent_type, ref = "Humans")

m1 <- glmer(
  choice ~ Agent_type * Emotion_selfreport +
    amount_of_cost_c + amount_of_allocation_c +
    (1 | ID),
  data = expdata_complete,
  family = binomial(link = "logit"),
  control = glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 1e5))
)

cat("\n===== 模型2（含交互）结果 =====\n")
print(summary(m1))

or_m1 <- broom.mixed::tidy(m1, effects = "fixed", conf.int = TRUE, conf.method = "Wald") %>%
  mutate(
    OR = exp(estimate),
    OR_low = exp(conf.low),
    OR_high = exp(conf.high)
  ) %>%
  select(term, estimate, std.error, statistic, p.value, OR, OR_low, OR_high)

cat("\n===== 模型2 OR (95%CI) =====\n")
options(scipen = 999)  # 关闭科学计数法显示
print(or_m1, digits = 4)

```
```{r}

cat("\n===== 模型2 OR (95%CI) =====\n")
options(scipen = 999)  # 关闭科学计数法显示
print(or_m1, digits = 4)
```

```{r}
##报告95%CIlogit
# 提取系数表
coefs <- summary(m1)$coefficients

# 计算 95% Wald CI (logit scale)
coefs_CI <- cbind(
  B        = coefs[, "Estimate"],
  SE       = coefs[, "Std. Error"],
  z        = coefs[, "z value"],
  p        = coefs[, "Pr(>|z|)"],
  CI_lower = coefs[, "Estimate"] - 1.96 * coefs[, "Std. Error"],
  CI_upper = coefs[, "Estimate"] + 1.96 * coefs[, "Std. Error"]
)

# 打印结果
round(coefs_CI, 3)

```

```{r}
# ============ 模型比较（是否需要交互项） ============
cat("\n===== 模型比较（m0 vs m1, Chisq） =====\n")
print(anova(m0, m1, test = "Chisq"))

# ============ 估计边际均值/预测概率（更直观） ============
cat("\n===== 估计边际均值：按 Agent_type x Emotion_selfreport （概率尺度） =====\n")
emm <- emmeans::emmeans(m1, ~ Agent_type * Emotion_selfreport, type = "response")
print(emm)
```
```{r}
#是否报告情绪时各agent type的比较
pairs(emmeans(m1, ~ Agent_type | Emotion_selfreport, type="response"))

```
```{r}
# 按 agent_type 分组，比较 emotion_selfreport 的差异
pairs(emmeans(m1, ~ Emotion_selfreport | Agent_type, type="response"))

```
```{r}
# 1) 先算每个 Agent 下的 self-report 条件均值 (response = 概率 / OR)
emm_tab <- emmeans(m1, ~ Emotion_selfreport | Agent_type, type = "response")

# 2) 成对比较，改成 Yes vs No，带置信区间和 p 值
ci_tab <- summary(
  pairs(emm_tab, reverse = TRUE),  # 翻转顺序 (Yes / No)
  infer = c(TRUE, TRUE)            # 给 CI 和 p 值
)

print(ci_tab)

# 列里会有 odds.ratio、lower.CL、upper.CL、p.value

```


```{r}
# 确保 Agent_type 是因子
expdata_complete$Agent_type <- factor(expdata_complete$Agent_type)

# 把 "human" 设为基线水平
expdata_complete$Agent_type <- relevel(expdata_complete$Agent_type, ref = "Humans")

m2 <- glmer(
    choice ~ Agent_type * Emotion_selfreport * amount_of_cost_c * amount_of_allocation_c
            - Agent_type:Emotion_selfreport:amount_of_cost_c:amount_of_allocation_c
            + (1 | ID),
  data = expdata_complete,
  family = binomial(link = "logit"),
  control = glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 1e5))
)

cat("\n===== 模型2（含交互）结果 =====\n")
print(summary(m2))
```






























```{r}
# ============ 读取数据 ============
file_path <- "~/Desktop/study2_GLMM.xlsx"
df <- readxl::read_excel(path = file_path, sheet = 2)

cat("列名：\n"); print(names(df))
cat("\nchoice/Group/Emotion_selfreport 的原始取值频数：\n")
print(table(df$choice, useNA = "ifany"))
print(table(df$Group, useNA = "ifany"))
print(table(df$Emotion_selfreport, useNA = "ifany"))
```

```{r cars}
library(dplyr)  
# ============ 因子化（显式levels，避免标签长度错误） ============
# 你的预期：choice = 0/1；Group = 1/2/3；Emotion_selfreport = 0/1
# 如有超出这些level的取值，会被给出警告并标记为 NA
valid_choice_levels <- c(0, 1)
valid_group_levels  <- c(1, 2, 4,5)
valid_emotion_levels <- c(0, 1)

# 标记异常
bad_choice <- setdiff(na.omit(unique(df$choice)), valid_choice_levels)
bad_group  <- setdiff(na.omit(unique(df$Group)), valid_agent_levels)
bad_emot   <- setdiff(na.omit(unique(df$Emotion_selfreport)), valid_emotion_levels)

if (length(bad_choice)>0) warning("choice 中存在非常规取值：", paste(bad_choice, collapse=", "))
if (length(bad_group)>0)  warning("Agent_type 中存在非常规取值：", paste(bad_group, collapse=", "))
if (length(bad_emot)>0)   warning("Emotion_selfreport 中存在非常规取值：", paste(bad_emot, collapse=", "))

expdata <- df %>%
  mutate(
    choice = factor(choice,
                    levels = valid_choice_levels,
                    labels = c("accept","punish")),
    Group = factor(Group,
                        levels = valid_group_levels,
                        labels = c("DeepSeek-R1","o3-mini","DeepSeek-v3","GPT-3.5"
                            )),
    Emotion_selfreport = factor(Emotion_selfreport,
                                levels = valid_emotion_levels,
                                labels = c("No Emotion Self-Report","Emotion Self-Report")),
    ID = as.factor(ID)
  )

cat("\n因子化后频数（确认标签）：\n")
print(table(expdata$choice, useNA = "ifany"))
print(table(expdata$Group, useNA = "ifany"))
print(table(expdata$Emotion_selfreport, useNA = "ifany"))


```


```{r pressure, echo=FALSE}

# ============ 数值控制变量中心化 ============
# 如果有缺失，会在后面 complete.cases 过滤
expdata <- expdata %>%
  mutate(
    amount_of_cost_c = scale(amount_of_cost, scale = FALSE)[,1],
    amount_of_allocation_c = scale(amount_of_allocation, scale = FALSE)[,1]
  )

# ============ 删去关键变量缺失的行（以免 glmer 报错） ============
vars_needed <- c("choice","Group","Emotion_selfreport","ID",
                 "amount_of_cost_c","amount_of_allocation_c")
expdata_complete <- expdata[complete.cases(expdata[, vars_needed]), ]

cat("\n完整案例数量：", nrow(expdata_complete), " / 原始行数：", nrow(expdata), "\n")

```


```{r}
##先不加随机效应
# 确保 Group 是因子，并设定参考水平
expdata_complete$Group <- factor(expdata_complete$Group)
expdata_complete$Group <- relevel(expdata_complete$Group, ref = "o3-mini")

# ============ 模型 A：固定效应 GLM ============ 
m4 <- glm(
  choice ~ Group * Emotion_selfreport * amount_of_cost_c 
        + Group * Emotion_selfreport * amount_of_allocation_c
        + amount_of_cost_c * amount_of_allocation_c * Group
        + Emotion_selfreport * amount_of_cost_c * amount_of_allocation_c,
  data = expdata_complete,
  family = binomial(link = "logit")
)

cat("\n===== 模型 A（无随机效应）结果 =====\n")
print(summary(m4))

```
```{r}
library(emmeans)

# 1. 提取 cost 在 Group × Emotion_selfreport 下的 simple slopes
emtrends <- emtrends(
  m4,
  specs = c("Group", "Emotion_selfreport"),  # 按组别和情绪条件
  var = "amount_of_cost_c"                   # 关注 cost 的斜率
)

cat("\n===== 模型 A: cost 敏感性 (分组 × 情绪) =====\n")
print(summary(emtrends))

# 2. 在每个组内，比较 Emotion_selfreport = Yes vs No 的差异
cat("\n===== 模型 A: 各组内情绪有/无对 cost 敏感性的影响 =====\n")
print(pairs(emtrends, by = "Group"))


```
```{r}
##先不加随机效应，四重交互
# 确保 Group 是因子，并设定参考水平
expdata_complete$Group <- factor(expdata_complete$Group)
expdata_complete$Group <- relevel(expdata_complete$Group, ref = "o3-mini")

# ============ 模型 A：固定效应 GLM ============ 
m5 <- glm(
  choice ~ Group * Emotion_selfreport * amount_of_cost_c * amount_of_allocation_c ,
  data = expdata_complete,
  family = binomial(link = "logit")
)

cat("\n===== 模型 A（无随机效应）结果 =====\n")
print(summary(m5))

```


```{r}
mu <- mean(expdata_complete$amount_of_allocation_c)
sd <- sd(expdata_complete$amount_of_allocation_c)

emtr_3 <- emtrends(
  m5,
  specs = c("Group","Emotion_selfreport"),
  var   = "amount_of_cost_c",
  at    = list(amount_of_allocation_c = c(mu - sd, mu, mu + sd)),
  type  = "link"   # 或 "response"
)

summary(emtr_3)
pairs(emtr_3, by = c("Group","amount_of_allocation_c"))
```

```{r}
##加随机效应
# 确保 Group 因子 & 参考水平
expdata_complete$Group <- factor(expdata_complete$Group)
expdata_complete$Group <- relevel(expdata_complete$Group, ref = "o3-mini")
# （可选）如果 Emotion_selfreport 是字符/数值，转成因子并设参考
# expdata_complete$Emotion_selfreport <- relevel(factor(expdata_complete$Emotion_selfreport), ref = "No Emotion Self-Report")

m6 <- glmer(
  choice ~ Group * Emotion_selfreport * amount_of_cost_c
        + Group * Emotion_selfreport * amount_of_allocation_c
        + (1 | ID),                                  # ← 随机截距
  data    = expdata_complete,
  family  = binomial(link = "logit"),
  control = glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 1e5)),
  #nAGQ    = 0                                        # 先用快一点的近似；稳了再调高
)

cat("\n===== 模型（含随机截距）结果 =====\n")
print(summary(m6))

```
```{r}
library(broom.mixed)
library(dplyr)

# 拟合好的模型对象 m6

# 1. 提取系数表 (固定效应)
coefs <- broom.mixed::tidy(m6, effects = "fixed")

# 2. 计算 95% CI（Wald 法）
ci <- confint(m6, parm = "beta_", method = "Wald")  # 或 method="profile"，更准但慢

# 3. 整合结果
results_table <- coefs %>%
  select(term, estimate, std.error, statistic, p.value) %>%
  mutate(
    CI_lower = ci[,1],
    CI_upper = ci[,2]
  ) %>%
  rename(
    B = estimate,
    SE = std.error,
    z = statistic,
    P = p.value
  )

# 打印表格
print(results_table, digits = 3)

# 如果要导出成 CSV
write.csv(results_table, "~/Desktop/model_results_m6.csv", row.names = FALSE)

```

```{r}
# 假设你的结果数据框叫 results_clean
library(dplyr)
# 并且里面有一列 P 值

results_clean <- results_clean %>%
  mutate(
    # 格式化为科学计数法（2位小数）
    P_scientific = formatC(P, format = "e", digits = 2),
    
    # 显著性标注
    sig = case_when(
      P < 0.001 ~ "***",
      P < 0.01  ~ "**",
      P < 0.05  ~ "*",
      TRUE      ~ "ns"
    ),
    
    # 合并显示（科学计数法 + 标注）
    P_display = paste0(P_scientific, " ", sig)
  )

# 查看结果
results_clean %>%
  select(term, B, SE, CI_lower, CI_upper, z, P_display)

```

```{r}
library(emmeans)
library(dplyr)

# ====== 1. 事后检验：Emotion × Cost，每个 Group 内 ======
emm_cost <- emtrends(
  m6,
  ~ Group * Emotion_selfreport,
  var = "amount_of_cost_c"
)

posthoc_cost <- pairs(emm_cost, by = "Group") %>%
  summary(infer = TRUE) %>%  # infer=TRUE 给出 95% CI
  as.data.frame() %>%
  mutate(effect = "Emotion × Cost")

# ====== 2. 事后检验：Emotion × Allocation，每个 Group 内 ======
emm_alloc <- emtrends(
  m6,
  ~ Group * Emotion_selfreport,
  var = "amount_of_allocation_c"
)

posthoc_alloc <- pairs(emm_alloc, by = "Group") %>%
  summary(infer = TRUE) %>%
  as.data.frame() %>%
  mutate(effect = "Emotion × Allocation")


# ====== 合并 cost & allocation 结果 ======
posthoc_results <- bind_rows(
  pairs(emm_cost, by = "Group",reverse = TRUE) %>%
    summary(infer = TRUE) %>%
    as.data.frame() %>%
    mutate(effect = "Emotion × Cost"),
  
  pairs(emm_alloc, by = "Group",reverse = TRUE) %>%
    summary(infer = TRUE) %>%
    as.data.frame() %>%
    mutate(effect = "Emotion × Allocation")
)

# ====== 统一改列名 ======
results_clean <- posthoc_results %>%
  rename(
    B        = estimate,
    CI_lower = asymp.LCL,
    CI_upper = asymp.UCL,
    z        = z.ratio,
    P        = p.value
  ) %>%
  mutate(
    OR       = exp(B),
    OR_lower = exp(CI_lower),
    OR_upper = exp(CI_upper)
  ) %>%
  select(Group, contrast, effect, B, SE, CI_lower, CI_upper, z, P, OR, OR_lower, OR_upper)

print(results_clean, digits = 3)

# ====== 5. 可选：导出到 CSV ======
write.csv(posthoc_results, "~/Desktop/posthoc_results_m6.csv", row.names = FALSE)

```


```{r}
##加随机效应
# 确保 Group 因子 & 参考水平
expdata_complete$Group <- factor(expdata_complete$Group)
expdata_complete$Group <- relevel(expdata_complete$Group, ref = "o3-mini")
# （可选）如果 Emotion_selfreport 是字符/数值，转成因子并设参考
# expdata_complete$Emotion_selfreport <- relevel(factor(expdata_complete$Emotion_selfreport), ref = "No Emotion Self-Report")

m6_2 <- glmer(
  choice ~ Group * Emotion_selfreport * amount_of_cost_c
        + Group * Emotion_selfreport * amount_of_allocation_c
        #amount_of_cost_c * amount_of_allocation_c * Group
        #+ Emotion_selfreport * amount_of_cost_c * amount_of_allocation_c
        + (1 + trial | ID),                                  # ← 随机截距
  data    = expdata_complete,
  family  = binomial(link = "logit"),
  control = glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 1e5)),
  #nAGQ    = 0                                        # 先用快一点的近似；稳了再调高
)

cat("\n===== 模型（含随机截距）结果 =====\n")
print(summary(m6_2))

```



































```{r}
library(broom.mixed)
library(dplyr)

# 拟合好的模型对象 m6

# 1. 提取系数表 (固定效应)
coefs <- broom.mixed::tidy(m6, effects = "fixed")

# 2. 计算 95% CI（Wald 法）
ci <- confint(m6, parm = "beta_", method = "Wald")  # 或 method="profile"，更准但慢

# 3. 整合结果
results_table <- coefs %>%
  select(term, estimate, std.error, statistic, p.value) %>%
  mutate(
    CI_lower = ci[,1],
    CI_upper = ci[,2]
  ) %>%
  rename(
    B = estimate,
    SE = std.error,
    z = statistic,
    P = p.value
  )

# 打印表格
print(results_table, digits = 3)

# 如果要导出成 CSV
write.csv(results_table, "~/Desktop/model_results_m6.csv", row.names = FALSE)

```






```{r}
library(emmeans)

# 如果 allocation 已中心化，均值就是 0
emtr_noAlloc <- emtrends(
  m6,
  specs = c("Group","Emotion_selfreport"),
  var   = "amount_of_cost_c",
  at    = list(amount_of_allocation_c = 0),  # 或 mean(expdata_complete$amount_of_allocation_c)
  type  = "link"   # 想和概率曲线一致可用 "response"
)

summary(emtr_noAlloc)
pairs(emtr_noAlloc, by = "Group")

```
```{r}
##加随机效应
# 确保 Group 因子 & 参考水平
expdata_complete$Group <- factor(expdata_complete$Group)

expdata_complete$Group <- relevel(expdata_complete$Group, ref = "o3-mini")

# （可选）如果 Emotion_selfreport 是字符/数值，转成因子并设参考
expdata_complete$Emotion_selfreport <- relevel(factor(expdata_complete$Emotion_selfreport), ref = "No Emotion Self-Report")

m7 <- glmer(
  choice ~ Group * Emotion_selfreport * amount_of_cost_c * amount_of_allocation_c
        + (1 | ID),                                  # ← 随机截距
  data    = expdata_complete,
  family  = binomial(link = "logit"),
  control = glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 1e5)),
  nAGQ    = 0                                        # 先用快一点的近似；稳了再调高
)

cat("\n===== 模型（含随机截距）结果 =====\n")
print(summary(m7))

```


```{r}
library(emmeans)

# 如果 allocation 已中心化，均值就是 0
emtr_noAlloc <- emtrends(
  m7,
  specs = c("Group","Emotion_selfreport"),
  var   = "amount_of_cost_c",
  at    = list(amount_of_allocation_c = 0),  # 或 mean(expdata_complete$amount_of_allocation_c)
  type  = "link"   # 想和概率曲线一致可用 "response"
)

summary(emtr_noAlloc)
pairs(emtr_noAlloc, by = "Group")

```

```{r}
# ============ 模型比较（是否需要交互项） ============
cat("\n===== 模型比较（m6 vs m7, Chisq） =====\n")
print(anova(m6, m7, test = "Chisq"))

#保留大的四重交互模型

```


```{r}
# m7：allocation = 均值（若中心化则 0）
em_cost_mu <- emtrends(
  m7,
  specs = c("Group","Emotion_selfreport"),
  var   = "amount_of_cost_c",
  at    = list(amount_of_allocation_c = mu),
  type  = "link"
)
cat("\n=== m7: cost 斜率（logit，allocation=均值）===\n")
print(summary(em_cost_mu))

cat("\n=== m7: 组内 (No - Emotion) 斜率差 ===\n")
print(pairs(em_cost_mu, by="Group"))


```



```{r}
##拆开模型逐个比较

library(lme4)
library(dplyr)

# ==== 拟合函数 ====
fit_one_group <- function(df_g, gname){
  message("Fitting group: ", gname)
  tryCatch({
    fit <- glmer(
      choice ~ Emotion_selfreport * amount_of_allocation_c * amount_of_cost_c +
        (1 | ID),
      data = df_g,
      family = binomial(link = "logit"),
      control = glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 1e5))
    )
    return(summary(fit))
  }, error = function(e){
    warning("模型在组 ", gname, " 拟合失败: ", e$message)
    return(NULL)
  })
}

# ==== 四个 group 循环 ====
all_groups <- levels(expdata_complete$Group)

results <- lapply(all_groups, function(g){
  df_g <- droplevels(filter(expdata_complete, Group == g))
  fit_one_group(df_g, g)
})

names(results) <- all_groups

# 查看结果，例如：
results$`DeepSeek-R1`



```
```{r}
results$`o3-mini`
```
```{r}
results$`DeepSeek-v3`
```

```{r}
results$`GPT-3.5`
```

```{r}
# ============ 因子化（显式levels，避免标签长度错误） ============ 
# 你的预期：choice = 0/1；Group = 1/2/3/5；Emotion_selfreport = 0/1；
# amount_of_cost = 0–9；amount_of_allocation = 10–15

valid_choice_levels     <- c(0, 1)
valid_group_levels      <- c(1, 2, 4, 5)
valid_emotion_levels    <- c(0, 1)
valid_cost_levels       <- 0:9
valid_allocation_levels <- 10:15

# 标记异常
bad_choice <- setdiff(na.omit(unique(df$choice)), valid_choice_levels)
bad_group  <- setdiff(na.omit(unique(df$Group)), valid_group_levels)
bad_emot   <- setdiff(na.omit(unique(df$Emotion_selfreport)), valid_emotion_levels)
bad_cost   <- setdiff(na.omit(unique(df$amount_of_cost)), valid_cost_levels)
bad_alloc  <- setdiff(na.omit(unique(df$amount_of_allocation)), valid_allocation_levels)

if (length(bad_choice)>0) warning("choice 中存在非常规取值：", paste(bad_choice, collapse=", "))
if (length(bad_group)>0)  warning("Group 中存在非常规取值：", paste(bad_group, collapse=", "))
if (length(bad_emot)>0)   warning("Emotion_selfreport 中存在非常规取值：", paste(bad_emot, collapse=", "))
if (length(bad_cost)>0)   warning("amount_of_cost 中存在非常规取值：", paste(bad_cost, collapse=", "))
if (length(bad_alloc)>0)  warning("amount_of_allocation 中存在非常规取值：", paste(bad_alloc, collapse=", "))

expdata_category <- df %>%
  mutate(
    choice = factor(choice,
                    levels = valid_choice_levels,
                    labels = c("accept","punish")),
    Group = factor(Group,
                   levels = valid_group_levels,
                   labels = c("DeepSeek-R1","o3-mini","DeepSeek-v3","GPT-3.5")),
    Emotion_selfreport = factor(Emotion_selfreport,
                                levels = valid_emotion_levels,
                                labels = c("No Emotion Self-Report","Emotion Self-Report")),
    amount_of_cost = factor(amount_of_cost,
                            levels = valid_cost_levels,
                            labels = as.character(valid_cost_levels)),
    amount_of_allocation = factor(amount_of_allocation,
                                  levels = valid_allocation_levels,
                                  labels = as.character(valid_allocation_levels)),
    ID = as.factor(ID)
  )

cat("\n因子化后频数（确认标签）：\n")
print(table(expdata_category$choice, useNA = "ifany"))
print(table(expdata_category$Group, useNA = "ifany"))
print(table(expdata_category$Emotion_selfreport, useNA = "ifany"))
print(table(expdata_category$amount_of_cost, useNA = "ifany"))
print(table(expdata_category$amount_of_allocation, useNA = "ifany"))


```

```{r}
# ============ 删去关键变量缺失的行（以免 glmer 报错） ============
vars_needed <- c("choice","Group","Emotion_selfreport","ID",
                 "amount_of_cost","amount_of_allocation")
expdata_category_complete <- expdata_category[complete.cases(expdata_category[, vars_needed]), ]

cat("\n完整案例数量：", nrow(expdata_category_complete), " / 原始行数：", nrow(expdata_category), "\n")

```

```{r}

expdata_category_complete <- expdata_category_complete %>%
  mutate(
    amount_of_allocation = relevel(amount_of_allocation, ref = "15")
  )


fit_fast <- glmer(
  choice ~  Group * Emotion_selfreport * amount_of_cost +
              Group * Emotion_selfreport * relevel(amount_of_allocation, ref = "15") +
              (1 | ID),
  data = expdata_category_complete,
  family = binomial(link = "logit"),
  nAGQ = 0,
  control = glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 1e5))
)

cat("\n===== 模型（含随机截距）结果 =====\n")
print(summary(fit_fast))

```

```{r}

cat("\n===== 模型（含随机截距）结果 =====\n")
print(summary(fit_fast))

```

```{r}
library(lme4)
library(dplyr)



# ---- 拟合函数 ----
fit_one_group <- function(df_g, gname){
  message("\n>>> 拟合 Group = ", gname, " <<<")
  fit <- glmer(
    choice ~ Emotion_selfreport * amount_of_cost * amount_of_allocation +
      (1 | ID),
    data = expdata_category_complete ,
    family = binomial(link = "logit"),
    control = glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 1e5))
  )
  print(summary(fit))
  return(fit)
}

# ---- 循环四个组 ----
all_groups <- levels(expdata_category_complete$Group)
results <- list()

for(g in all_groups){
  df_g <- filter(expdata_category_complete, Group == g) %>% droplevels()
  results[[g]] <- fit_one_group(df_g, g)
}

# ---- 结果对象在 results 里，summary 已经依次打印 ----

```

